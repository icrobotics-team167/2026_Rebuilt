// Copyright (c) 2026 FRC 167
// https://github.com/icrobotics-team167
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file at
// the root directory of this project.

package frc.cotc.swerve;

import static edu.wpi.first.units.Units.*;

import com.ctre.phoenix6.CANBus;
import com.ctre.phoenix6.configs.*;
import com.ctre.phoenix6.hardware.*;
import com.ctre.phoenix6.signals.*;
import com.ctre.phoenix6.swerve.*;
import com.ctre.phoenix6.swerve.SwerveModuleConstants.*;
import edu.wpi.first.math.Matrix;
import edu.wpi.first.math.numbers.N1;
import edu.wpi.first.math.numbers.N3;
import edu.wpi.first.units.measure.*;

// Generated by the 2026 Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
public class TunerConstants {
    // Both sets of gains need to be tuned to your individual robot.

    // The steer motor uses any SwerveModule.SteerRequestType control request with
    // the
    // output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
    private static final Slot0Configs steerGains = new Slot0Configs()
            .withKP(100)
            .withKI(0)
            .withKD(0.5)
            .withKS(0.1)
            .withKV(3.24)
            .withKA(0)
            .withStaticFeedforwardSign(StaticFeedforwardSignValue.UseClosedLoopSign);
    // When using closed-loop control, the drive motor uses the control
    // output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
    private static final Slot0Configs driveGains = new Slot0Configs().withKP(0.1).withKI(0).withKD(0).withKS(0)
            .withKV(0.124);

    // The closed-loop output type to use for the steer motors;
    // This affects the PID/FF gains for the steer motors
    private static final ClosedLoopOutputType kSteerClosedLoopOutput = ClosedLoopOutputType.Voltage;
    // The closed-loop output type to use for the drive motors;
    // This affects the PID/FF gains for the drive motors
    private static final ClosedLoopOutputType kDriveClosedLoopOutput = ClosedLoopOutputType.Voltage;

    // The type of motor used for the drive motor
    private static final DriveMotorArrangement kDriveMotorType = DriveMotorArrangement.TalonFX_Integrated;
    // The type of motor used for the drive motor
    private static final SteerMotorArrangement kSteerMotorType = SteerMotorArrangement.TalonFX_Integrated;

    // The remote sensor feedback type to use for the steer motors;
    // When not Pro-licensed, Fused*/Sync* automatically fall back to Remote*
    private static final SteerFeedbackType kSteerFeedbackType = SteerFeedbackType.FusedCANcoder;

    // The stator current at which the wheels start to slip;
    // This needs to be tuned to your individual robot
    private static final Current kSlipCurrent = Amps.of(120);

    // Initial configs for the drive and steer motors and the azimuth encoder; these
    // cannot be null.
    // Some configs will be overwritten; check the `with*InitialConfigs()` API
    // documentation.
    private static final TalonFXConfiguration driveInitialConfigs = new TalonFXConfiguration();
    private static final TalonFXConfiguration steerInitialConfigs = new TalonFXConfiguration()
            .withCurrentLimits(
                    new CurrentLimitsConfigs()
                            // Swerve azimuth does not require much torque output, so we can set a
                            // relatively
                            // low
                            // stator current limit to help avoid brownouts without impacting performance.
                            .withStatorCurrentLimit(Amps.of(60))
                            .withStatorCurrentLimitEnable(true));
    private static final CANcoderConfiguration encoderInitialConfigs = new CANcoderConfiguration();
    // Configs for the Pigeon 2; leave this null to skip applying Pigeon 2 configs
    private static final Pigeon2Configuration pigeonConfigs = null;

    // CAN bus that the devices are located on;
    // All swerve devices must share the same CAN bus
    public static final CANBus kCANBus = new CANBus("", "./logs/example.hoot");

    // Theoretical free speed (m/s) at 12 V applied output;
    // This needs to be tuned to your individual robot
    public static final LinearVelocity kSpeedAt12Volts = MetersPerSecond.of(5.12);

    // Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns;
    // This may need to be tuned to your individual robot
    private static final double kCoupleRatio = 3.857142857142857;

    public static final double kDriveGearRatio = 6.026785714285714;
    public static final double kSteerGearRatio = 26.09090909090909;
    public static final Distance kWheelRadius = Inches.of(2);

    private static final boolean kInvertLeftSide = false;
    private static final boolean kInvertRightSide = true;

    private static final int kPigeonId = 1;

    // These are only used for simulation
      publi sta
    private static final MomentOfInertia kDriveInertia = KilogramSquareMeters.of(0.01)  // Si
    public static final Voltage kSteerFrictionVoltage = Volts.of(0.2);  publi st atic final Voltage kDriveFrictionVoltage =

    
    public static final SwerveDrivetrainConstants Drive
        new SwerveDrivetrainConstants()
            .withCANBusName(kCANBus.getName())

            .withPigeon2Configs(pigeonConfigs); 
            static final SwerveModuleConstants
            TalonFXConfiguration, Tal
            tantCreator =

                    TalonFXConfiguration, TalonFXConfi    .withDriveMotorGearRatio(kDriveGearRatio)         .withStee     .withCouplingGearRatio(kCouplhWheelRadius(kWheelRadius)
            .withSteerMotorGains(steerGains)
            .withDriveMotorGains(driveGains)
            .withSteerMotorClosedLoopOutput(kSte
            .withDriveMotorClosedLoopOutpu
            .withSlipCurrent(kSlipCurrent)
            .withSpeedAt12Volts(kSpeedAt12Vo
            .withDriveMotorType(kDriveMotorType)
            .withSteerMotorType(kSteerMotorType)
            .withFeedbackSource(kSteerFeed
            .withDriveMotorInitialConfigs(driveI
            .withSteerMotorInitialConfigs(steerI
            .withEncoderInitialConfigs(encoderIn
            .withSteerInertia(kSteerInertia)
            .withDriveInertia(kDriveInertia)
            .withSteerFrictionVoltage(kSteerFrictionVoltage)
            .withDriveFrictionVoltage(kDriveFrictionVoltage);
            
            t
            ic final int kFrontLeftDriveMotorId = 3;
            ic final int kFrontLeftSteerMotorId = 2;

    private stati
    private static final boolean kFrontLeftSteerMotorInv
    private static final boolean kFrontLeftEncoderInvert
    
    private static final Distance kFrontLeftXPos = Inches.of(16);
    private static final Distance kFrontLeftYPos = Inches.of(11);
    

    private static final int kFrontRightDriveMotorId = 1;
    private static final int kFrontRightSteerMotorId = 0;

    private static
    private static final boolean kFrontRightSteerMotorInv
    private static final boolean kFrontRightEncoderInvert
    
    private static final Distance kFrontRightXPos = Inches.of(16);
    private static final Distance kFrontRightYPos = Inches.of(-11);
    

    private static final int kBackLeftDriveMotorId = 7;
    private static final int kBackLeftSteerMotorId = 6;

    private stat
    private static final boolean kBackLeftSteerMotorInv
    private static final boolean kBackLeftEncoderInvert
    
    private static final Distance kBackLeftXPos = Inches.of(-16);
    private static final Distance kBackLeftYPos = Inches.of(11);
    

    private static final int kBackRightDriveMotorId = 5;
    private static final int kBackRightSteerMotorId = 4;

    private stati
    private static final boolean kBackRightSteerMotorInv
    private static final boolean kBackRightEncoderInvert
    
    private static final Distance kBackRightXPos = Inches.of(-16);
    private static final Distance kBackRightYPos = Inches.of(-11);
    

            TalonFXConfiguration, TalonFXConfiguration, CANcoderCo
        FrontLeft =

                kFrontLeftSteerMotorId,    kFrontLeftDriveMotorId,         kFr     kFrontLeftE
            ncoderOffset,
                    kFrontLeftXPos,
                    kFrontLeftYPos,
                    kInvertLeftSide,
                    kFrontLeftSteerMotorInve
                    kFrontLeftEncod
                    c final SwerveM
                    nFXConfiguration
                    ht =
                    tantCreator.createModuleCon
                kFrontRightSteerMotorId,    kFrontRightDriveMotorId,         kFro     kFrontRight
            EncoderOffset,
                    kFrontRightXPos,
                    kFrontRightYPos,
                    kInvertRightSide,
                    kFrontRightSteerMotorInve
                    kFrontRightEncod
                    c final SwerveMo
                    nFXConfiguration,
                     =
                    tantCreator.createModuleCons
                kBackLeftSteerMotorId,    kBackLeftDriveMotorId,         kB     kBackLeftEn
            coderOffset,
                    kBackLeftXPos,
                    kBackLeftYPos,
                    kInvertLeftSide,
                    kBackLeftSteerMotorInve
                    kBackLeftEncod
                    c final Swerve
                    nFXConfiguration
                    t =
                    tantCreator.createModuleCo
                kBackRightSteerMotorId,    kBackRightDriveMotorId,         kBa     kBackRightE
            ncoderOffset,
                    kBackRightXPos,
                    kBackRightYPos,
                    kInvertRightSide,
                    kBackRightSteerMotorInve
                    kBackRightEncod
                    
                    rive class utiliz
                    c class TunerSwerveDrivetrain
                    

       
     * 
     * 
     
       * <p>This constructs the underlying hardware devices, so users should not construct the devic
         * 
         *
         *
         * @pa
         * ram modules Constants for each specific module
         * 
         */
         * 
         u
            SwerveDrivetrainConstants drivetrainConstants, SwerveModuleConstants<?, 
          super(TalonFX::             ew, TalonFX::new, CANcoder::new, d
         
        
                
            
        
    